# Processes images for a timelapse video.
# Accepts imagers from the "archive" folder where files are named according to date and time, e.g. 20240518_1700.png (generated by rpi_timelapse.py)
# Resizes images to set resolution, adds a timestamp based on the filename, and discards dark images.
# Must include input and output folders. Output folder is emptied when the script is run.

from token import NUMBER
from PIL import Image, ImageDraw, ImageFont
import os
import shutil
import numpy as np
import multiprocessing
from concurrent.futures import ProcessPoolExecutor, as_completed

# Discard photos with overall brightness below this value (e.g. dark night photos)
BRIGHTNESS_THRESHOLD = 100

# If number of workers is 0, this script uses (logical processors - 1) workers for multithreading.
# So for example 7 workers for a CPU with 8 threads.
NUMBER_OF_WORKERS = 7

OUTPUT_IMAGE_SIZE = (1600, 1200)

CURRENT_DIRECTORY = os.path.dirname(os.path.realpath(__file__))
IMAGES_DIRECTORY = os.path.join(CURRENT_DIRECTORY, "archive")
OUTPUT_DIRECTORY = os.path.join(CURRENT_DIRECTORY, "output")


def clear_output_folder(output_folder):
    for filename in os.listdir(output_folder):
        file_path = os.path.join(output_folder, filename)
        try:
            if os.path.isfile(file_path) or os.path.islink(file_path):
                os.unlink(file_path)
        except Exception as e:
            print(f"Failed to delete {file_path}. Reason: {e}")


# Calculate and return overall brightness value of 0-255 using grayscale version of the image
def calculate_brightness(image_path):
    with Image.open(image_path) as img:
        grayscale_img = img.convert("L")
        np_img = np.array(grayscale_img)
        brightness = np.mean(np_img)
        return brightness


def resize_image(image_path, output_path, size=OUTPUT_IMAGE_SIZE):
    with Image.open(image_path) as img:
        resized_img = img.resize(size, Image.LANCZOS)
        resized_img.save(output_path)
        return resized_img


# Turn filename into a prettier representation of date and time
# For example 20240518_1800.png into 2024-05-18, 18:00     
def format_filename(filename):
    name, _ = os.path.splitext(filename)
    date_part = name[:8]
    time_part = name[9:]
    formatted_date = f"{date_part[:4]}-{date_part[4:6]}-{date_part[6:]}"
    formatted_time = f"{time_part[:2]}:{time_part[2:]}"
    return f"{formatted_date}, {formatted_time}"


def add_timestamp_to_image(image, source_text, position):
    formatted_text = format_filename(source_text)
    draw = ImageDraw.Draw(image)
    try:
        font = ImageFont.truetype("arial.ttf", 25)
    except IOError:
        font = ImageFont.load_default()
    text_bbox = draw.textbbox((0, 0), formatted_text, font=font)
    text_size = (text_bbox[2] - text_bbox[0], text_bbox[3] - text_bbox[1])
    text_position = (10, 10)  # 10 pixels padding from the top left corner
    x, y = text_position
    draw.text(text_position, formatted_text, font=font, fill="white", stroke_width=1, stroke_fill="black")
    
    return image


def process_folder(IMAGES_DIRECTORY, OUTPUT_DIRECTORY):
    if NUMBER_OF_WORKERS == 0:        
        max_workers = multiprocessing.cpu_count() - 1
    else:
        max_workers = NUMBER_OF_WORKERS
        
    print(f"Processing images using {max_workers} workers.")
    filenames = [f for f in os.listdir(IMAGES_DIRECTORY) if os.path.isfile(os.path.join(IMAGES_DIRECTORY, f))]
    with ProcessPoolExecutor(max_workers=max_workers) as executor:
        futures = [executor.submit(process_image, os.path.join(IMAGES_DIRECTORY, filename), filename) for filename in filenames]
        for future in as_completed(futures):
            try:
                future.result()
            except Exception as exc:
                print(f'Generated an exception: {exc}')


def process_image(file_path, filename):
    brightness = calculate_brightness(file_path)
    rounded_brightness = round(brightness)
    if rounded_brightness >= BRIGHTNESS_THRESHOLD:
        output_file_path = os.path.join(OUTPUT_DIRECTORY, filename)
        resized_img = resize_image(file_path, output_file_path)
        stamped_img = add_timestamp_to_image(resized_img, filename, (1600, 1200))
        stamped_img.save(output_file_path)
        print(f"{filename} processed")
    else:
        print(f"{filename} discarded (brightness {rounded_brightness})")    


def main():
    clear_output_folder(OUTPUT_DIRECTORY)
    process_folder(IMAGES_DIRECTORY, OUTPUT_DIRECTORY)


if __name__ == "__main__":
    main()